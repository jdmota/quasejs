// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`basic: ast 1`] = `
Object {
  "body": Object {
    "loc": Object {
      "end": Object {
        "column": 21,
        "line": 1,
        "pos": 21,
      },
      "start": Object {
        "column": 16,
        "line": 1,
        "pos": 16,
      },
    },
    "stuff": Object {
      "id": 6,
      "image": "10000",
      "label": "NUM",
    },
    "type": "EXP",
  },
  "loc": Object {
    "end": Object {
      "column": 25,
      "line": 1,
      "pos": 25,
    },
    "start": Object {
      "column": 0,
      "line": 1,
      "pos": 0,
    },
  },
  "params": Array [
    Object {
      "id": 5,
      "image": "id1",
      "label": "ID",
    },
    Object {
      "id": 5,
      "image": "id2",
      "label": "ID",
    },
  ],
  "type": "PROGRAM",
}
`;

exports[`basic: ast 2`] = `
Object {
  "body": Object {
    "loc": Object {
      "end": Object {
        "column": 14,
        "line": 1,
        "pos": 14,
      },
      "start": Object {
        "column": 11,
        "line": 1,
        "pos": 11,
      },
    },
    "stuff": Object {
      "id": 5,
      "image": "id1",
      "label": "ID",
    },
    "type": "EXP",
  },
  "loc": Object {
    "end": Object {
      "column": 18,
      "line": 1,
      "pos": 18,
    },
    "start": Object {
      "column": 0,
      "line": 1,
      "pos": 0,
    },
  },
  "params": Array [
    Object {
      "id": 5,
      "image": "id1",
      "label": "ID",
    },
  ],
  "type": "PROGRAM",
}
`;

exports[`basic: ast 3`] = `"Unexpected token eof, expected END (at 1:14)"`;

exports[`basic: conflicts 1`] = `Array []`;

exports[`basic: generation 1`] = `
"/* eslint-disable */
const Q=require(\\"@quase/parser\\");


  class Tokenizer extends Q.Tokenizer{
    
    constructor(input){
      super(input);
      this.table=[c=>0,c=>c==44?2:c==45?3:48<=c&&c<=57?5:65<=c&&c<=90?6:97<=c&&c<=100?6:c==101?7:c==102?10:103<=c&&c<=122?6:0,c=>0,c=>c==62?4:0,c=>0,c=>48<=c&&c<=57?5:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=109?6:c==110?8:111<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=99?6:c==100?9:101<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=116?6:c==117?11:118<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=109?6:c==110?12:111<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=122?6:0];
      this.finals={\\"2\\":3,\\"4\\":4,\\"5\\":6,\\"6\\":5,\\"7\\":5,\\"8\\":5,\\"9\\":2,\\"10\\":5,\\"11\\":5,\\"12\\":1};
      this.labels=[\\"\\",\\"FUN\\",\\"END\\",\\"COMMA\\",\\"ARROW\\",\\"ID\\",\\"NUM\\"];
    }
    initial(){return{id:\\"initial\\",label:\\"initial\\"};}
    eof(){return{id:\\"eof\\",label:\\"eof\\"};}
    
  codePointAt(index) {
    const first = this.input.charCodeAt(index);
    const size = this.input.length;
    if (
      first >= 0xD800 && first <= 0xDBFF &&
      size > index + 1
    ) {
      const second = this.input.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  
    
readToken() {
  const { input, table, finals, labels } = this;
  const length = input.length;
  const prevPos = this.pos;

  let state = 1;
  let i = this.pos;

  while ( i < length ) {
    const char = this.codePointAt( i );
    const nextState = table[ state ]( char );
    if ( nextState ) {
      state = nextState;
      if ( char > 0xffff ) {
        i += 2;
      } else {
        i++;
      }
    } else {
      break;
    }
  }

  const id = finals[state];
  if ( id == null ) {
    this.unexpectedChar();
  }
  const image=input.slice(prevPos,i);
  const splitted=image.split(/\\\\r\\\\n?|\\\\n/g);
  const newLines=splitted.length-1;
  this.pos=i;
  if (newLines>0) {
    this._lineStart=this.pos-splitted[newLines].length;
    this._curLine+=newLines;
  }
  return {
    id,
    label: labels[id],
    image
  };
}
  }
class Parser extends Q.Parser{
constructor(text){super(new Tokenizer(text));}

    expect(id) {
      const token = this.token;
      if ( token.id !== id ) {
        const labels = this.tokenizer.labels;
        throw this.error(
          \`Unexpected token \${labels[token.id]||token.id}, expected \${labels[id]||id}\`
        );
      }
      this.next();
      return token;
    }
    
/*EXP*/f2(){let $l=this.startNode();let $n_stuff;switch(this.token.id){case 6:$n_stuff=this.expect(6);break;case 5:$n_stuff=this.expect(5);break;default:this.unexpected();}return {type:\\"EXP\\",stuff:$n_stuff,loc:this.locNode($l)};}
/*PROGRAM*/f1(){let $l=this.startNode();let $n_params=[],$n_body;this.expect(1);switch(this.token.id){case 5:$n_params.push(this.expect(5));loop:while(true){switch(this.token.id){case 3:this.expect(3);$n_params.push(this.expect(5));break;default:break loop;}}break;}this.expect(4);$n_body=this.f2();this.expect(2);this.expect(\\"eof\\");return {type:\\"PROGRAM\\",params:$n_params,body:$n_body,loc:this.locNode($l)};}
parse(){return this.f1();}}
module.exports=Parser;
"
`;

exports[`check conflicts on repetitions: conflicts 1`] = `
Array [
  "In ZeroOrMore(2:18-2:22), when finding 'A', choice conflicts: 'A' (2:18-2:21) | Empty(2:18-2:22)",
  "In OneOrMore(3:12-3:16), when finding 'B', choice conflicts: 'B' (3:12-3:15) | Empty(3:12-3:16)",
]
`;

exports[`check conflicts on repetitions: generation 1`] = `
"/* eslint-disable */
const Q=require(\\"@quase/parser\\");


  class Tokenizer extends Q.Tokenizer{
    
    constructor(input){
      super(input);
      this.table=[c=>0,c=>c==65?2:c==66?3:0,c=>0,c=>0];
      this.finals={\\"2\\":1,\\"3\\":2};
      this.labels=[\\"\\",\\"'A'\\",\\"'B'\\"];
    }
    initial(){return{id:\\"initial\\",label:\\"initial\\"};}
    eof(){return{id:\\"eof\\",label:\\"eof\\"};}
    
  codePointAt(index) {
    const first = this.input.charCodeAt(index);
    const size = this.input.length;
    if (
      first >= 0xD800 && first <= 0xDBFF &&
      size > index + 1
    ) {
      const second = this.input.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  
    
readToken() {
  const { input, table, finals, labels } = this;
  const length = input.length;
  const prevPos = this.pos;

  let state = 1;
  let i = this.pos;

  while ( i < length ) {
    const char = this.codePointAt( i );
    const nextState = table[ state ]( char );
    if ( nextState ) {
      state = nextState;
      if ( char > 0xffff ) {
        i += 2;
      } else {
        i++;
      }
    } else {
      break;
    }
  }

  const id = finals[state];
  if ( id == null ) {
    this.unexpectedChar();
  }
  const image=input.slice(prevPos,i);
  const splitted=image.split(/\\\\r\\\\n?|\\\\n/g);
  const newLines=splitted.length-1;
  this.pos=i;
  if (newLines>0) {
    this._lineStart=this.pos-splitted[newLines].length;
    this._curLine+=newLines;
  }
  return {
    id,
    label: labels[id],
    image
  };
}
  }
class Parser extends Q.Parser{
constructor(text){super(new Tokenizer(text));}

    expect(id) {
      const token = this.token;
      if ( token.id !== id ) {
        const labels = this.tokenizer.labels;
        throw this.error(
          \`Unexpected token \${labels[token.id]||token.id}, expected \${labels[id]||id}\`
        );
      }
      this.next();
      return token;
    }
    
/*RULE2*/f2(){let $l=this.startNode();this.expect(2);loop:while(true){switch(this.token.id){case 2:this.expect(2);break;default:break loop;}}this.expect(2);return {type:\\"RULE2\\",loc:this.locNode($l)};}
/*RULE1*/f1(){let $l=this.startNode();loop:while(true){switch(this.token.id){case 1:this.expect(1);break;default:break loop;}}this.expect(1);this.f2();this.expect(\\"eof\\");return {type:\\"RULE1\\",loc:this.locNode($l)};}
parse(){return this.f1();}}
module.exports=Parser;
"
`;

exports[`supports empty: conflicts 1`] = `Array []`;

exports[`supports empty: generation 1`] = `
"/* eslint-disable */
const Q=require(\\"@quase/parser\\");


  class Tokenizer extends Q.Tokenizer{
    
    constructor(input){
      super(input);
      this.table=[c=>0,c=>c==65?2:0,c=>0];
      this.finals={\\"2\\":1};
      this.labels=[\\"\\",\\"'A'\\"];
    }
    initial(){return{id:\\"initial\\",label:\\"initial\\"};}
    eof(){return{id:\\"eof\\",label:\\"eof\\"};}
    
  codePointAt(index) {
    const first = this.input.charCodeAt(index);
    const size = this.input.length;
    if (
      first >= 0xD800 && first <= 0xDBFF &&
      size > index + 1
    ) {
      const second = this.input.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  
    
readToken() {
  const { input, table, finals, labels } = this;
  const length = input.length;
  const prevPos = this.pos;

  let state = 1;
  let i = this.pos;

  while ( i < length ) {
    const char = this.codePointAt( i );
    const nextState = table[ state ]( char );
    if ( nextState ) {
      state = nextState;
      if ( char > 0xffff ) {
        i += 2;
      } else {
        i++;
      }
    } else {
      break;
    }
  }

  const id = finals[state];
  if ( id == null ) {
    this.unexpectedChar();
  }
  const image=input.slice(prevPos,i);
  const splitted=image.split(/\\\\r\\\\n?|\\\\n/g);
  const newLines=splitted.length-1;
  this.pos=i;
  if (newLines>0) {
    this._lineStart=this.pos-splitted[newLines].length;
    this._curLine+=newLines;
  }
  return {
    id,
    label: labels[id],
    image
  };
}
  }
class Parser extends Q.Parser{
constructor(text){super(new Tokenizer(text));}

    expect(id) {
      const token = this.token;
      if ( token.id !== id ) {
        const labels = this.tokenizer.labels;
        throw this.error(
          \`Unexpected token \${labels[token.id]||token.id}, expected \${labels[id]||id}\`
        );
      }
      this.next();
      return token;
    }
    
/*RULE1*/f1(){let $l=this.startNode();switch(this.token.id){case 1:this.expect(1);break;default:}this.expect(\\"eof\\");return {type:\\"RULE1\\",loc:this.locNode($l)};}
parse(){return this.f1();}}
module.exports=Parser;
"
`;

exports[`typescript: generation 1`] = `
"/* eslint-disable */
import Q from \\"@quase/parser\\";
export type $Position = {pos:number;line:number;column:number;};
export type $Location = {start:$Position;end:$Position;};
export interface $Base<T> {type:T;loc:$Location;}
export type $5 = {id:5;label:\\"ID\\";image:string;};
export type $6 = {id:6;label:\\"NUM\\";image:string;};
export interface EXP extends $Base<'EXP'> {stuff:$6|$5;};
export interface PROGRAM extends $Base<'PROGRAM'> {params:($5)[];body:EXP;};

  class Tokenizer extends Q.Tokenizer{
    table:((c:number)=>number)[];finals:{[key:number]:number};labels:string[];
    constructor(input:string){
      super(input);
      this.table=[c=>0,c=>c==44?2:c==45?3:48<=c&&c<=57?5:65<=c&&c<=90?6:97<=c&&c<=100?6:c==101?7:c==102?10:103<=c&&c<=122?6:0,c=>0,c=>c==62?4:0,c=>0,c=>48<=c&&c<=57?5:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=109?6:c==110?8:111<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=99?6:c==100?9:101<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=116?6:c==117?11:118<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=109?6:c==110?12:111<=c&&c<=122?6:0,c=>48<=c&&c<=57?6:65<=c&&c<=90?6:97<=c&&c<=122?6:0];
      this.finals={\\"2\\":2,\\"4\\":3,\\"5\\":6,\\"6\\":5,\\"7\\":5,\\"8\\":5,\\"9\\":4,\\"10\\":5,\\"11\\":5,\\"12\\":1};
      this.labels=[\\"\\",\\"'fun'\\",\\"','\\",\\"'->'\\",\\"'end'\\",\\"ID\\",\\"NUM\\"];
    }
    initial(){return{id:\\"initial\\",label:\\"initial\\"};}
    eof(){return{id:\\"eof\\",label:\\"eof\\"};}
    
  codePointAt(index:number):number {
    const first = this.input.charCodeAt(index);
    const size = this.input.length;
    if (
      first >= 0xD800 && first <= 0xDBFF &&
      size > index + 1
    ) {
      const second = this.input.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  
    
readToken() {
  const { input, table, finals, labels } = this;
  const length = input.length;
  const prevPos = this.pos;

  let state = 1;
  let i = this.pos;

  while ( i < length ) {
    const char = this.codePointAt( i );
    const nextState = table[ state ]( char );
    if ( nextState ) {
      state = nextState;
      if ( char > 0xffff ) {
        i += 2;
      } else {
        i++;
      }
    } else {
      break;
    }
  }

  const id = finals[state];
  if ( id == null ) {
    this.unexpectedChar();
  }
  const image=input.slice(prevPos,i);
  const splitted=image.split(/\\\\r\\\\n?|\\\\n/g);
  const newLines=splitted.length-1;
  this.pos=i;
  if (newLines>0) {
    this._lineStart=this.pos-splitted[newLines].length;
    this._curLine+=newLines;
  }
  return {
    id,
    label: labels[id],
    image
  };
}
  }
class Parser extends Q.Parser{
constructor(text:string){super(new Tokenizer(text));}

    expect(id:number|string) {
      const token = this.token;
      if ( token.id !== id ) {
        const labels = this.tokenizer.labels;
        throw this.error(
          \`Unexpected token \${labels[token.id]||token.id}, expected \${labels[id]||id}\`
        );
      }
      this.next();
      return token;
    }
    
/*EXP*/f2():EXP{let $l=this.startNode();let $n_stuff;switch(this.token.id){case 6:$n_stuff=this.expect(6);break;case 5:$n_stuff=this.expect(5);break;default:this.unexpected();}return {type:\\"EXP\\",stuff:$n_stuff,loc:this.locNode($l)};}
/*PROGRAM*/f1():PROGRAM{let $l=this.startNode();let $n_params=[],$n_body;this.expect(1);switch(this.token.id){case 5:$n_params.push(this.expect(5));loop:while(true){switch(this.token.id){case 2:this.expect(2);$n_params.push(this.expect(5));break;default:break loop;}}break;}this.expect(3);$n_body=this.f2();this.expect(4);this.expect(\\"eof\\");return {type:\\"PROGRAM\\",params:$n_params,body:$n_body,loc:this.locNode($l)};}
parse(){return this.f1();}}
export default Parser;
"
`;
